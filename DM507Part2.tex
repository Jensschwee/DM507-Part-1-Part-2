\documentclass{article}
\usepackage[utf8]{inputenc} %dansk tegnsæt
\usepackage[danish]{babel}  %Sætter dokumentet til dansk dvs at auto generat navne bliver danske
\usepackage{amsmath} %mat
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{bold-extra}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{color}
\usepackage{parskip}% http://ctan.org/pkg/parskip

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\pagestyle{fancy}
\fancyhead[CO,CE]{Projekt del 2 - DM507 - jesph13 og jenss12}
\begin{document}
{\centering
\huge
Projekt del 2\\
Algoritmer og datastrukturer (DM507)\\
\large
\bigskip
Institut for Matematik og Datalogi Syddansk Universitet, Odense\\
\bigskip
20. Maj 2015\\
\bigskip
Af Jesper Wohlert Hansen \& Jens Hjort Schwee\\
}
\newpage

\section*{Introduktion}
Denne rapport dækker over en implementation af Huffman kodning, herunder operationer til enkodning og dekodning af filer. Rapportens hovedafsnit beskriver disse operationer, mens at et sidste afsnit er tilset tests.

\subsection*{Systemkrav \& kørsel}
Bemærk, for at køre programmerne er \textbf{Java 8} påkrævet, da der i programmerne benyttes stream\footnote{https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html} bibliotekets funktionalitet.

\bigskip

De to Java programmer, \texttt{Encode} og \texttt{Decode}. Køres således:

\begin{verbatim}
    java Encode <input> <encoding>
\end{verbatim}

\begin{verbatim}
    java Decode <encoding> <output>
\end{verbatim}

\newpage

\section*{Opgave 1}
I denne opgave skal der konstrueres et program, som kan læse en input fil og producere et Huffman-kodet version af denne fil. For at gøre dette, laves der "gennemløb" af input-filen.

\subsection*{Første gennemløb}

Inputfilen indlæses og der bliver allokeret et nyt array til at indeholde frekvenserne for de 256 forskellige typer input som programmet godtager. Herefter læses filen linje for linje hvorved at der genereres bitstrenge af længde 8 (én byte). Denne byte kalder for \texttt{readBits} og vil typisk se således ud: \texttt{01001000}. \texttt{readBits} kan herefter parses til et heltal, som kan bruges som index i \texttt{frequencies} arrayet. Her lægges der 1 til frekvensen for at optælle frekvensen for hver byte, hvorefter alle frekvenserne skrives til output filen gennem \texttt{BitOutputStream}.

Til sidst i gennemløbet bygges der et Huffman træ med frekvenserne som input. \texttt{build} operationen er dækket i følgende afsnit: % INDSÆT SENERE
Roden af Huffman træet bliver returneret fra build, og denne rods data kan bruges til at lave Huffman koden.

\begin{lstlisting}
// Encode.java
BitInputStream in = new BitInputStream(inFile);
BitOutputStream out = new BitOutputStream(outFile);

int bit;
int[] frequencies = new int[256];
String readBits = "";

while ((bit = in.readBit()) != -1) {
  readBits += "" + bit;
  if (readBits.length() % 8 == 0) {
    frequencies[Integer.parseInt(readBits, 2)] += 1;
    readBits = "";
  }
}

for (int i : frequencies) out.writeInt(i);

Element e = Huffman.build(frequencies);
encodedTable = Huffman.encode((DictBinTree.Node) e.data);
\end{lstlisting}

\newpage
\subsection*{Huffman træet}
Måden Huffman træet bygges på er ved at kalde metoden \texttt{Huffman.build(tabel)}, den kaldes med agumentet int array, som indefolder frekevenserne over de enkelte karatærer.\\
Det første der sker i metoden tæller hvor mange elementer der ligger i array som indeholder nogle frekvenser. Dette gøres for at vide hvor stor det træ der skal bygges skal være.\\
Alle de elementer der indeholder en værdig som ikke er 0, bliver indsat i en \texttt{PQHeap}.\\
For loop'et bygger træet, først hentets de to mindste elementer i \texttt{pqHeap}. Deres key's læses og sættes som \\texttt{key} på en ny \texttt{Node}, hvor de første element der bliv hentet på heap'en sættes som venster barn og den anden som højre barn. Til sidst i loop'et indsættes det nye \texttt{Node} i heap'en. Når loop'et terminere hentes det sidste element i heap'en og retuneres.
\begin{lstlisting}
// Huffman.java
public static Element build(int[] table) {
	int elementCount = (int) IntStream.of(table)
		.filter(n -> n != 0)
		.count();
		
        if (elementCount > 0) {
			PQ pqHeap = new PQHeap(elementCount);
			IntStream.range(0, table.length)
				.filter(n -> table[n] != 0)
				.forEach(n -> pqHeap.insert(new
					Element(table[n], tree.new Node(n))));
					
		for (int i = 0; i < elementCount - 1; i++) {
			Element left = pqHeap.extractMin();
			Element right = pqHeap.extractMin();
			
			int key = left.key + right.key;

			DictBinTree.Node node = tree.new Node(key);
			
			node.left = (DictBinTree.Node) left.data;
			node.right = (DictBinTree.Node) right.data;
            
			pqHeap.insert(new Element(key, node));
		}
		return pqHeap.extractMin();
	}
	return null;
}
\end{lstlisting}
Huffman enkodningen laves i \texttt{huffman} klassen gennem metoden \texttt{encode}. Dette er en metode som kalder den rekursive version af sig selv indtil alle knuder er gennemløbet. Hertil skal bruges en tabel til at indeholde alle Huffman koderne, hvilket er repræsenteret ved \texttt{String} array, hvor indekset er nøglen for knuden (hyppigheden?). Den \texttt{recursiveEncode} konstruerer så en bitstreng rekursivt ved at lægge 0 til enden hvis den skal til venstre, og 1 til enden hvis den skal til højre. Den stopper gemmer bitstrengen i array'et når der ikke er flere børn.

\begin{lstlisting}
// Huffman.java
public static String[] encode(DictBinTree.Node root) {
  String[] table = new String[256];
  if(root.right != null || root.left != null)
    recursiveEncode(root, table, "");
  else
    recursiveEncode(root, table, "0");
  return table;
}
...

private static void recursiveEncode(DictBinTree.Node node, String[] table, String bitString) {
  if (node == null) return;
  if (node.left == null && node.right == null) {
    table[node.key] = bitString;
  } else {
    recursiveEncode(node.left, table, bitString + "0");
    recursiveEncode(node.right, table, bitString + "1");
  }
}
\end{lstlisting}

\subsection*{Andet gennemløb}

I andet gennemløb benyttes lignende kode fra første gennemløb til at genåbne inputfilen og læse byte'sne. Forskellen er, at der i dette gennemløb skrives huffmannkodningen for hver karakter til outputfilen ved opslag i den tabel der blev modtaget fra \texttt{Huffman.encode}.

\begin{lstlisting}
while ((bit = in.readBit()) != -1) {
  readBits += "" + bit;
  if (readBits.length() % 8 == 0) {
    for (char c : encodedTable[Integer.parseInt(readBits, 2)].toCharArray())
      out.writeBit(Integer.parseInt(Character.toString(c)));
    readBits = "";
  }
}
\end{lstlisting}


\newpage

\section*{Opgave 2}
Formålet med denne delopgave er reetablering af filer der er blivet kompimeret via opgave's program \texttt{Encode}. Når \texttt{Decode} har kørt kommer der en file dekompimeret.\\
Det første der sker i programemt er at der læses de 256 ints, som ligger først i filen, disse bliver brugt til at bygge huffman træet. Disse ints bliver gemt i et array og træet bygges via \texttt{Huffman.build}. For at kunne oversætte tilbage til udgangspunktet skal der vides hvilke præfix koder der er blevet brugt. Disse findes ved at kalde: \texttt{Huffman.decode(Node)}
\begin{lstlisting}
//Huffman.java
public static Map<String, Integer> decode(DictBinTree.Node root) {
        Map<String, Integer> table = new HashMap<String, Integer>();
        if(root.right != null || root.left != null)
            recursiveDecode(root, table, "");
        else
            recursiveDecode(root, table, "0");
        return table;
}

private static void recursiveDecode(DictBinTree.Node node, 
Map<String, Integer> table, String bitString){
	if (node == null) return;
		if (node.left == null && node.right == null)
			table.put(bitString, node.key);
		else {
            recursiveDecode(node.left, table, bitString + "0");
            recursiveDecode(node.right, table, bitString + "1");
		}
}
\end{lstlisting}
Metoden decode, bruges til at få et HashMap med alle præfix koderne. Der er valgt at benytte et HashMap med en String som nøglen og integer som skal skrives som værdig, da der værd gang der bliver læst en bit i file skal tejkes hvorhvidt dette er en præfix kode. Herved opnås den bedste køretid for disse opslag.\\
Før der kaldes \texttt{recursiveDecode}, sikkers der at der ikke kun er en \texttt{Node}, i træet, dette gøres for at koden også virker ved indput med kun et tegn.
Kaldet til \texttt{recursiveDecode} fra \texttt{decode} , består af hvor den skal state med at lave koderne, som i dette tilfælde er rode noden, i hvad for et Map koderne skal indsættes og hvad præfix koden skal starte med.\\
Metoden \texttt{recursiveDecode} er bygget op med rekusive kald, til sig selv. Hvis denne node ikke er null, og ikke har nogle børn, vides det at det er en node som indeholder en nøgle som er blevet kodet via huffman træet, derfor tilføjes til til mappet med tilhørende præfix kode. Hvis den der i mod har børn vides det at dette ikke er en af præfix koderne. Derfor kaldes \texttt{recursiveDecode}, med både højer og venster barn, og præfix koden ændres herefter.\\
Når \texttt{recursiveDecode} er kørt færdig er alle noder blevet ramt og alle præfix koder er indsat i HashMap'et. Sluteligt retuneres det.
\begin{lstlisting}
//Decode.java
FileInputStream inFile = new FileInputStream(args[0]);
FileOutputStream outFile = new FileOutputStream(args[1]);

BitInputStream in = new BitInputStream(inFile);
BitOutputStream out = new BitOutputStream(outFile);
...
Map<String, Integer> decodeTable = Huffman.decode((DictBinTree.Node)e.data);
String readBits = "";
int bit;
int writeCount = e.key;
while ((bit = in.readBit()) != -1) {
	readBits += "" + bit;
	Integer decode = decodeTable.get(readBits);
	if (decode != null) {
		String test = Integer.toBinaryString(decode);
		for (int i = test.length() - 8; i < 0; i++) 
 			out.writeBit(0);	
 			
		for (char c : test.toCharArray())
			out.writeBit(Integer.parseInt(Character.toString(c)));

		readBits = "";
		writeCount--;
		if (writeCount < 1) 
			break;
	}
}
...
\end{lstlisting}
Efter at havde fået HashMappet med præfix koderne. \texttt{writeCount}  sættes til antalet af elementer der skal skrives til output filen, dette kommer fra huffman træes rods værdig.\\
Programemt forsætter med at læse input filen, bit for bit. Hver gang der er læst en bit ligges det til \texttt{readBits} som indeholder alt hvad der er læst.
Der søges i mappet om hvad der er læst er en præfix kode, hvis den ikke er så læs næste bit uden for foratage yderligere. Hvis vi derimod har fat i en præfix kode, så skal der skrives til output filen. \\
For at få det rigtige skrævet i filen skal der sikkers at det som der skal skrives er 8 bit's, hvis det ikke er tilfældet skrives der nogle patting bits med "0" først, for herved at opnå det rigtige output. Når formatet er på plads skrives resten af de bits som repesetære den binære værdig af den integer som skal skrives. readBits bliver nulstillet og hvor mange elementer der skal skrives tælles ned. Hvis alle elementer er skrævet ud stoppes udskrivningen, herved fjernes evt. patten bits fra den endelige fil.
\newpage
\section*{Test}
Begge programmer er testet på følgende måde:
\begin{itemize}
  \item Terminal med direkte input
  \item Terminal med redirection of input + output
\end{itemize}
\bigskip
\subsection*{Encode test}
Encode er testet med tomme indputs, og med file som indput.
Herefter er det huffman træ der er blevet lavet, se i debuggeren, og tegnet i hånden, for at sikker korektheden heraf.\\
\bigskip
\subsection*{Decode test}
Decode er test med tomme indput, og med indput hvor der står de 256 int's først i filen. \\
Huffman træ'er der er blivet bygget er se i debugeren, og udarbejdet i hånden for at sikker korekthed heraf.\\
Yderligere er der verifiseret indput og output ved at se på endelige filer som har været igemmen både Encode og Decode.

\end{document}
