\documentclass{article}
\usepackage[utf8]{inputenc} %dansk tegnsæt
\usepackage[danish]{babel}  %Sætter dokumentet til dansk dvs at auto generat navne bliver danske
\usepackage{amsmath} %mat
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{bold-extra}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\pagestyle{fancy}
\fancyhead[CO,CE]{Projekt del 1 - jesph13 og jenss12}
\begin{document}
{\centering
\huge
Projekt del 1\\
Algoritmer og datastrukturer (DM507)\\
\large
\bigskip
Institut for Matematik og Datalogi Syddansk Universitet, Odense\\
\bigskip
8. April 2015\\
\bigskip
Af Jesper Wohlert Hansen \& Jens Hjort Schwee\\
}
\newpage

\section*{Introduktion}
Denne rapport dækker over implementationer af datastukturerne \texttt{Priority Queue} og \texttt{Binary Tree} ved brug af hhv. en \texttt{Heap} og en \texttt{Dictionary} samt tilhørende algoritmer til behandling af disse strukturer. Disse implementationer er skrevet i Java og implementerer følgende interfaces:

\begin{verbatim}
public interface PQ {
    public Element extractMin();
    public void insert(Element e);
}
\end{verbatim}


\begin{verbatim}
public interface Dict {
    public void insert(int k);
    public int[] orderedTraversal();
    public boolean search(int k);
}
\end{verbatim}

De konkrete implementationer er baseret på pseudokode fra bogen \emph{Introduction to Algorithms, third edition}\footnote{http://mitpress.mit.edu/books/introduction-algorithms}.


Rapporten indeholder uddybende beskrivelser af de implementerede datastrukturer med tilhørende kodestumper. De mest trivielle kodestumper er undladt til fordel for korthed.

\newpage

\section*{Opgave 1}
Målet med denne opgave er at implementere en prioritetskø der implementerer interfacet \texttt{PQ}. Køen skal have en heap struktur, og skal indeholde og behandle objekter af klassen \texttt{Element}. Vi ønsker at fokusere på interface metoderne, samt private metodekald fra interface-metoderne.

\subsection*{extractMin()}

\begin{lstlisting}
// PQHeap.java
@Override
public Element extractMin() {
    Element min;
    min = heap[0];    
\end{lstlisting}
For at udtrække det mindste element fra heapen, benytter vi, at vi arbejder med en min-heap. Det vil sige, at vores mindste element altid vil være på plads 0 - \texttt{heap[0]}.
\begin{lstlisting}    
    heap[0] = heap[heapsize-1];
    heapsize--;
    minheapify(0);
    return min;
}
\end{lstlisting}
Herefter sætter vi det første element til at have samme værdi, som de sidste og reducerer heapsizen, således at vi kan heapifisere direkte fra første element. Dette fungerer da det største element nu er på roden af en min-heap, og hele heapen derfor skal reorganiseres.
\begin{lstlisting}
// PQHeap.java
private void minheapify(int i) {
    int smallest;
    int left = left(i);
    int right = right(i);
    Element swap;

    if (left <= heapsize && heap[left].key < heap[i].key)
        smallest = left;
    else
        smallest = i;
    if (right <= heapsize && heap[right].key < heap[smallest].key)
        smallest = right;
    if (smallest != i) {
        swap = heap[i];
        heap[i] = heap[smallest];
        heap[smallest] = swap;
        minheapify(smallest);
    }
}
\end{lstlisting}


Indsæt beskrivelse
\begin{lstlisting}
/**
 * Inserts the Element e into the heap
 *
 * param e - the element to be inserted
 */
@Override
public void insert(Element e) {
    heapsize++;
    heap[heapsize-1] = e;
    decreaseKey(heapsize-1);
}
\end{lstlisting}


\newpage


\section*{Opgave 2}
Indsæt beskrivelse
\begin{lstlisting}
public boolean search(int k) {
  Node x = root;
  while (x != null && k != x.key) {
        if (k < x.key) {
            x = x.left;
        } else {
            x = x.right;
        }
    }

    if (x == null) {
        return false;
    } else if (x.key == k) {
        return true;
    }
    return false;
}
\end{lstlisting}
Indsæt beskrivelse
\begin{lstlisting}
public int[] orderedTraversal() {
    outOrder = new int[size];
    inOrderTreeWalk(root);
    return outOrder;
}
\end{lstlisting}
\newpage
\section*{Opgave 3}
Koden for hvordan \texttt{Treesort} er implamenteret, den gør brug af datastrukturen \texttt{DictBinTree} som er et binært tree.\\
Ført læses indputter fra scanneren og gemmens i en arrayliste, herefter ligges disse tal i det binnære træ.\\
Til slut hentes alle talende ud igen af træ'et i sortede orden.
\begin{lstlisting}
//Treesort.java
List<Integer> numbers = new ArrayList<Integer>();
Scanner scan = new Scanner(System.in);
while (scan.hasNextInt()) {
	numbers.add(scan.nextInt());
}
Dict dict = new DictBinTree();
for (int number : numbers) {
	dict.insert(number);
}
for (int number : dict.orderedTraversal()) {
	System.out.println(number);
}
\end{lstlisting}
Koden for hvordan \texttt{Heapsort} er implamenteret, den gør brug af datastrukturen \texttt{PQHeap} som er en priotes kø.\\
Ført læses indputter fra scanneren og gemmens i en arrayliste, herefter ligges disse tal i det kø'en.\\
Til slut hentes alle talende ud igen af træ'et i sortede orden.
\begin{lstlisting}
//Heapsort.java
List<Integer> numbers = new ArrayList<Integer>();
Scanner scan = new Scanner(System.in);
while (scan.hasNextInt()) {
	numbers.add(scan.nextInt());
}
PQ pq = new PQHeap(numbers.size());
for (int number : numbers) {
	pq.insert(new Element(number, number));
}
for (int number: numbers) {
	System.out.println(pq.extractMin().key);
}
\end{lstlisting}
\newpage
\section*{Test}
Begge datastrukturer er testet på følgende måde:
\begin{itemize}
  \item console med indput
  \item console med redirection og output file  
  \item udleveret \texttt{TestProjectPartI} klasse
\end{itemize}
\bigskip
Datastrukeren vil virke på alle int's som ligger i int32 der er ikke testet for støre indput end dette. \texttt{Treesort} og \texttt{Heapsort} virker begge med disse indput.

\end{document}